# -*- coding: utf-8 -*-
"""hw-02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1siqSaYag9lszCO2veffNx-SSYCch8RP6

# Домашнее задание 02

## Математика и все подобное

В этом ДЗ попробуем сфокусироваться все еще на основах языка, но в более прямолинейном формате &ndash; целью будет научиться работать с какими-то математическими функциями без использования `scipy`.

**Некоторые правила**:

1. Не меняйте уже имеющиеся импорты и названия функций. Если ДЗ будет проверяться автоматически (а скорее всего, так и будет) &ndash; любое из этих изменений приведет к тому, что вы, скорее всего, получите ошибку при проверке.

2. Если будет автоматическая проверка, вам надо будет либо сдать целиком файл `.ipynb`, либо сдать только код соответствующей функции в каждом из заданий. Соответственно, если вы сдаете только код функции, необходимые импорты и определения будут добавлены при проверке автоматически. Например,
    * определение типа `point = tuple[int, int]`
    * `import math` в большинстве заданий, в которых требуется работать с функциями из этого модуля

### 1. Примитивная математика

В Python большинство математических функций уже встроены в язык и вычисляются за вас. Достаточо просто импортировать модуль `math`: в нем есть как базовые математические функции, так и тригонометрия, и многое другое.

За полным составом модуля `math` можете обратиться к его [документации](https://docs.python.org/3/library/math.html) &ndash; достаточно быстро пробежаться глазами по списку доступных функций, чтобы прикинуть, что с его помощью можно считать.

**1.0. Функции**

Если вы все еще некомфортно чувствуете себя с функциями, советуем перед выполнением заданий потренироваться на чем-то более простом.

1. Попробуйте написать простые функции, вычисляющие какие-то математические или физические выражения.
2. Убедитесь, что вы правильно понимаете, как работают аргументы функций.
3. В этом задании используются `type hints` &ndash; это не что-то слишком сложное, просто указание ожидаемых типов аргументов и возвращаемого значения для функций. Подробнее можно почитать [здесь](https://www.infoworld.com/article/3630372/get-started-with-python-type-hints.html).

**1.1. Площадь треугольника**

Напишите функцию, принимающую три точки (каждая &ndash; `tuple[int, int]`, то есть пара из x- и y-координаты) и возвращающую площадь треугольника с вершинами в этих точках.

*Подсказка*: есть много способов искать площадь треугольника, среди которых:
* формула Герона (не советую, будет очень противно это писать)
* теорема синусов
* векторное (псевдоскалярное) произведение

Обычно третий способ лучше, так как производит меньшую ошибку (из-за неточности типа `float`), чем первые два, но вы можете выбрать любой удобный. Если вам не знакомы эти термины, можно за 5 минут по первому запросу в гугле выяснить, как их применять здесь.
"""
import math
from math import *
point = tuple[int, int]

def triangle_area(a: point, b: point, c: point) -> float:
    return 0.5 * abs((b[0] - a[0])*(c[1] - a[1]) - (c[0] - a[0])*(b[1] - a[1]))

print(triangle_area((0, 0), (0, 5), (4, 0)))  # должно печатать 10

"""**1.2. Величина угла**

Напишите функцию, определяющую величину угла $\angle abc$ **в градусах**, где $a$, $b$ и $c$ &ndash; переданные точки.

Здесь вам уже точно понадобится использование функций из `math`. Обратите особенное внимание на `math.atan2` &ndash; в языках программирования для определения угла чаще используется именно эта функция.

*Подсказка*: еще может быть полезно (снова) посмотреть на скалярное и векторное (псевдоскалярное) произведение векторов. Они выражаются двумя способами:
* $(x_1, y_1) \cdot (x_2, y_2) = x_1 x_2 + y_1 y_2 = |(x_1, y_1)| \cdot |(x_2, y_2)| \cdot \cos(\alpha)$
* $(x_1, y_1) \times (x_2, y_2) = x_1 y_2 - x_2 y_1 = |(x_1, y_1)| \cdot |(x_2, y_2)| \cdot \sin(\alpha)$
<br/>где $\alpha$ &ndash; направленный угол между векторами.
"""

def angle(a: point, b: point, c: point) -> float:
    ab = [b[0] - a[0], b[1] - a[1]]
    bc = [c[0] - b[0], c[1] - b[1]]
    return math.atan2(bc[1], bc[0]) - math.atan2(ab[1], ab[0])

print(angle((-1, 1), (0, 0), (3, 3)))  # должно печатать pi/2, то есть 1.5707...

"""**1.3. Сложная математика**

Посчитайте функцию распределения (Cumulative Distribution Function) для [*нормально распределенной*](https://en.wikipedia.org/wiki/Normal_distribution) случайной величины.

Случайная величина &ndash; число, имеющее определенную вероятность находиться в каких-либо интервалах значений. Информацию про нормальное распределение, в том числе и про его функцию распределения ($\Phi(x) = \mathtt{Probability}(\xi < x)$), можно найти по ссылке выше.

Реализуйте функцию, которая для данного $x$ и параметров распределения $\mu$ (матожидание) и $\sigma$ (среднеквадратичное отклонение) вычисляет $\Phi(x)$.

*Подсказка*: воспользуйтесь формулой с Википедии. Все необходимые функции и константы есть в модуле `math`. Полное понимание происходящего для решения задания не обязательно, достаточно просто правильно переписать формулу.
"""


def normal_cdf(x: float, mu: float, sigma: float) -> float:
    return 0.5 * (1 + math.erf((x - mu)/ (sigma * 2**0.5)))

print(normal_cdf(42.0, 42.0, 13.0))  # должно печатать 0.5
print(normal_cdf(32.0, 42.0, 13.0))  # должно печатать 0.2208781...
"""**1.4. [Дополнительное задание] Функции высшего порядка**

Реализуйте предыдущее задание, но в виде функции высшего порядка: `normal_cdf(mu: float, sigma: float)` должна возвращать **функцию**, принимающую $x$ и возвращающую $\Phi(x)$ для соответствующего распределения.
"""

def normal_cdf(mu: float, sigma: float):
    return lambda x: 0.5 * (1 + math.erf((x - mu)/(sigma*2**0.5)))

cdf = normal_cdf(42.0, 13.0)
print(cdf(42.0))  # должно печатать 0.5
print(cdf(32.0))  # должно печатать 0.2208781...

"""**1.5. Немного физики**

Есть снаряд с массой $m$ кг. Он вылетает из точки с координатами $(0, 0)$ под углом $\alpha$ градусов к земной поверхности со скоростью $v$ м/с. Силой сопротивления воздуха можно пренебречь.

(Одна единица расстояния на координатной плоскости равна $1$ метру).

Найдите
* самое высокое его положение в воздухе (максимальную y-координату)
* на какой координате x он приземлится

Проверьте свои решения для каких-то произвольных входных данных, убедитесь, что вывод совпадает с вашими расчетами. Константу $g$ считайте равной $9.81\mathrm{m/s^2}$.
"""

def highest_point(m: float, alpha: float, v: float) -> float:
    return (math.sin(math.radians(alpha)) * v) ** 2 / (2*9.81)
def travel_distance(m: float, alpha: float, v: float) -> float:
    if alpha in [0,90,180]:
        return 0
    return 2 * math.sin(math.radians(2*alpha)) * v**2/ 9.81


print(highest_point(12, 45, 10))
print(travel_distance(10, 90, 10))

"""### 2. Многочлены

В этом блоке мы попробуем без использования модуля `scipy` реализовать некоторые операции над многочленами.

Как мы уже начали работать (в некоторых группах) с ними на практике, договоримся, что будем представлять многочлен $F(x) = a_n x^n + \ldots + a_0$ в виде массива его коэффициентов `a = [a0, a1, ..., an]`.

Например, многочлен $F(x) = 2x^2 - 7x + 19$ будет представлен в виде массива `[19, -7, 2]`.

**2.0. Повторяем основные моменты с практики**

1. Степень многочлена. Как можно заметить, на многочлен степени $d$ нам нужен массив длины $d + 1$, поэтому степень на один меньше представляющего многочлен массива.
"""

polynomial = list[float | int]

def degree(p: polynomial) -> int:
    return len(p) - 1

"""2. Вычисление значения многочлена в точке &ndash; достаточно просто посчитать соответствующие степени $x$, умножить на коэффициенты и сложить. <br/>
Стоит правда отметить, что каждый раз заново считать $x^i$ неэффективно, поэтому будем хранить соответствующую степень $x$ в `power_of_x` и пересчитывать с каждой итерацией цикла (если до этого в ней лежало $x^{i-1}$, то после умножения на $x$ будет $x^i$)

> Про `enumerate` можно прочитать [здесь](https://realpython.com/python-enumerate/).
"""

def calculate(p: polynomial, x: float) -> float:
    value = 0
    power_of_x = 1  # x^0
    for i, pi in enumerate(p):
        value += pi * power_of_x
        power_of_x *= x  # следующая степень x
    return value

"""3. Сложение. Когда два многочлена складываются, их соответствующие коэффиценты складываются. Создадим новый массив коэффициентов и запишем в него соответствующие суммы.

**Упражнение**: модифицируйте функцию сложения ниже так, чтобы старший коэффициент, равный нулю, удалялся. Например, `add([3, 0, 2], [-1, 0, -2])` должен возвращать `[2]`, а не `[2, 0, 0]`.

Можете забить, но потом тогда с делением будет более неприятно разбираться...
"""

def add(p: polynomial, q: polynomial) -> polynomial:
    r = [0.0 for _ in range(max(len(p), len(q)))]
    for i, pi in enumerate(p):
        r[i] += pi
    for i, qi in enumerate(q):
        r[i] += qi
    flag = False
    a = []
    for i in r[::-1]:
        if i != 0.0:
            flag = True
        if flag:
            a.append(i)
    return a

"""4. Умножение &ndash; аналогично сложению, но немного сложнее. При умножении $P(x)$ и $Q(x)$ коэффициенты получаются равными $r_i = \sum\limits_{k \leqslant i} p_k q_{i-k}$. <br/>
Можно реализовать это двумя вложенными циклами: по $i$ и по $k$. Способ, рассмотренный на практике, более интуитивный, но неприятный: надо ограничивать $k$ так, чтобы не выйти за границы массивов `p` и `q`. <br/>
Рассмотрим другой способ, более приятный в реализации: для каждого $i$ и $j$ прибавим к $r_{i+j}$ произведение $p_i q_j$.
"""

def multiply(p: polynomial, q: polynomial) -> polynomial:
    r = [0.0 for _ in range(len(p) + len(q) - 1)]
    for i, pi in enumerate(p):
        for j, qj in enumerate(q):
            r[i + j] += p[i] * q[j]
    return r

"""#### Другие функции с многочленами

Здесь мы рассмотрим:
* преобразование в строку
* вычисление производной
* поиск корня
* деление

Преобразование в строку уже было затронуто на практике (у групп, у которых успели начать эту тему). Но здесь попробуем добавить некоторый функционал.

5. Сначала рассмотрим реализацию преобразования в строку с практики (немного упрощенную для повышения читабельности):
    * Научимся по коэффициенту приводить в строку его одночлен: это будет либо `c`, если степень равна нулю, либо `cx`, если степень равна один, либо `cx^d`, если степень больше. Обозначим такое преобразование функцией `monomial_to_string`.
> Подробнее про форматные строки можно прочитать [здесь](https://realpython.com/python-f-strings/).
    * Преобразуем каждый коэффициент в строковое представление с помощью этой функции в цикле.
    * Полученные строки соединим через ` + ` с помощью `' + '.join(...)'`.
    * У нас осталась проблема с отрицательными коэффициентами: вместо того, чтобы писать ` + -7x^2`, мы бы хотели сразу писать ` - 7x^2`. Для ее исправления просто заменим все вхождения подстроки `' + -'` на `' - '`.
"""

def monomial_to_string(coeff: float, d: int) -> str:
        if d == 0:
            return f'{coeff}'
        elif d == 1:
            return f'{coeff}x'
        return f'{coeff}x^{d}'

def to_string(p: polynomial):
    monomials = []
    for d in reversed(range(len(p))):  # идем по убыванию степеней
        monomials.append(monomial_to_string(p[d], d))
    result = ' + '.join(monomials)
    if result[-1] == '0':
        return result[:-4].replace(' + -', ' - ').replace('1', '')
    else:
        return result.replace(' + -', ' - ').replace('1', '')

"""**2.1. Улучшенный вывод**

Измените эти функции так, чтобы
* мономы с нулевыми коэффициентами не выводились (это уже, кажется, есть в файле с практики)
* коэффициенты, равные $\pm 1$, не выводились (выводить `x^4` вместо `1x^4`)
"""

print(to_string([0, 2, -1, 5]))  # должно вывести 5x^3 - x^2 + 2x

"""**2.1+. Улучшенный вывод-2**

Реализуйте функцию `to_latex`, преобразующую многочлен в LaTeX-формат. Возвращаемая строка должна корректно рендериться техом в изображение.

На самом деле для этого не так много надо поменять:
* внимательно посмотрите на синтаксис теха для степеней (вы хотите $x^{18}$, а не $x^18$)
* формулы в техе обрамляются в знаки `$` с двух сторон

Для проверки, что все ок, запустите следующую после вашего решения ячейку
"""

def to_latex(p: polynomial) -> str:
    c = to_string(p)
    b = ''
    flag = True
    for i in range(len(c)):
        if c[i] == '0':
            flag = False
        elif c[i] == '+' or c[i] == '-':
            flag = True
        if flag == True:
            b += c[i]
    b = b.replace(' + - ', ' - ').replace(' - + ', ' + ')
    x = [str(i) for i in range(10)]
    v = 0
    for i in b:
        if i not in x:
            v += 1
        else:break
    return b[v:]

# Проверка

from IPython.display import display, Math, HTML

def load_mathjax_in_cell_output():
    display(HTML("<script src='https://www.gstatic.com/external_hosted/mathjax/latest/MathJax.js?config=default'></script>"))
get_ipython().events.register('pre_run_cell', load_mathjax_in_cell_output)

latex_str = to_latex([0, 0, -1, 7, 1, 0, 0, 0, 13, -21, 1, 12, -5])
Math(latex_str)
# должно отобразить -5x^12 + 12x^11 + x^10 - 21x^9 + 13x^8 + x^4 + 7x^3 - x^2
# только в виде красивой формулы

"""**2.2. Производная**

Напишите функцию, которая вычисляет производную многочлена (то есть многочлен, являющийся производной данного). Для этого достаточно просто знать, что $(x^n)' = n \cdot x^{n-1}$.
"""

def derivative(p: polynomial) -> polynomial:
    a = [0 for i in range(len(p))]
    for i in range(len(p)):
        a[i] += p[i] * i
    if len(a) == 1:
        return [0]
    else:
        del a[0]
        return a

print(derivative([1, 2, 3]))
# должно вывести [2, 6], так как (3x^2 + 2x + 1)' = 6x + 2
print(derivative([10]))
# должно вывести [0], так как 10' = 0

"""**2.3. Деление в столбик**

Требуется посчитать неполное частное и остаток при делении одного многочлена на другой.

Это не самая тривиальная для реализации операция, поэтому здесь будет много указаний по ее реализации:

1. Попробуйте сначала выразить вычитание. Оно выражается через сложение и умножение на $-1$.
2. Дальше просто достаточно много раз делать вычитание. Например, если мы делим $2x^3 + 3x^2 + x + 2$ на $3x^2 + 6$, сначала мы расположим их друг под другом в старшем разряде, и получим, что $x^1$ входит в ответ с коэффициентом $\frac{2}{3}$. <br/>
Собственно, вычтем из исходного многочлена $3x^2 + 6$, умноженный на $\frac{2}{3}x$. Останется $3x^2 - 3x + 2$.
3. Продолжим то же самое для следующей степени $x$: теперь уже $x^0$ входит с коэффициентом $\frac{3}{3} = 1$. После вычитания получим остаток $-3x - 4$.
4. Как только степень остатка стала меньше степени делителя, надо останавливаться.
"""

def divide(p: polynomial, q: polynomial) -> tuple[polynomial, polynomial]:
    quot, rem = [], []
    ...
    return quot, rem  # неполное частное и остаток

print(divide([2, 1, 3, 2], [6, 0, 3]))
# пример выше, должно получиться [1.0, 0.6666..] и [-4.0, -3.0]

"""**2.4. Ввод многочлена**

Реализуйте функцию, принимающую строку (`str`), представляющую многочлен (в том виде, в котором вы его выводите функцией `to_string`) и возвращающую массив его коэффициентов.

Обратите внимание, что вам будет немного тяжело с `.split(' + ')`, потому что для одночлены могут разделяться как плюсами, так и минусами. Более того, вам важно отличать плюс от минуса, чтобы знать, какой знак у одночлена.

Способы решения:
* *сложный*: пройтись циклом `for` по всем символам полученной строки, хранить текущее состояние (какую часть одночлена мы уже успели прочитать, и какой знак перед ним шел), и по каждому символу обновлять известную информацию
* *более простой*: сделать `.split()` по пробелам, тогда у вас будут чередоваться знаки `+/-` и строки вида `cx^d` &ndash; после будет достаточно обработать их парами (достать `c` и `d` из `'cx^d'` несложно &ndash; хватит сплита по строке `'x^'`).
"""
def from_string(s: str) -> polynomial:
    flag = True
    if s[0] == '-':
        flag = False
        s = s[1:]
    a = s.split(' ')
    polynomial = [0 for i in range(int(a[0][-1]) + 1)]
    for i in range(len(a)):
        if len(a[i]) > 1:
            if 'x' in a[i]:
                if a[i][0] != 'x':
                    polynomial[int(a[i][-1])] = int(a[i][:a[i].index('x')])
                else:
                    polynomial[int(a[i][-1])] = 1
    if 'x' not in a[-1]:
         polynomial[0] = int(a[-1])
    if flag == False:
        polynomial[-1] = -polynomial[-1]
    for i in range(len(a) - 1):
         if a[i] == '-':
             polynomial[int(a[i + 1][-1])] = -int(a[i + 1][:a[i + 1].index('x')])

    return polynomial

print(from_string('x^7 - 2x^4 + 1'))
# должно напечатать [1, 0, 0, 0, -2, 0, 0, 1]

"""**2.5. [Дополнительное задание] Поиск корня**

Реализуйте [метод Ньютона](https://ru.algorithmica.org/cs/numerical/newton/) или [вещественный двоичный поиск](https://ru.algorithmica.org/cs/interactive/binary-search/#бинарный-поиск-с-вещественными-аргументами) (для многочленов нечетной степени) и напишите функцию, находящую хотя бы один корень многочлена.

Рекомендуется метод Ньютона (благо, методы для вычисления значений и производной у вас уже должны быть написаны к этому моменту).

Точность найденного корня в идеале должна быть не меньше $10^{-6}$.

Проверьте получаемый ответ на разных многочленах с помощью функции `calculate`, которую мы реализовывали раньше: значение многочлена в найденной точке должно быть достаточно близко к нулю.

Возвращайте `None`, если корень не найдется.
"""

def find_root(p: polynomial) -> float | None:
    ...

